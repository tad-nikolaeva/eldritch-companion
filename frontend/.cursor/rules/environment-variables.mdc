---
description: 
globs: 
alwaysApply: true
---
# Environment Variables Guide

This project uses a sophisticated, multi-level system for managing environment variables. All variables for the application should be consumed **only** from [src/frontend/src/shared/environment/environment.ts](mdc:src/frontend/src/shared/environment/environment.ts).

There are three types of variables:

### 1. Build-Time Variables

These variables are "baked" into the code during the build process.

-   **Source:** Files in the `src/frontend/environments/` directory (e.g., `.env.development`, `.env.build`). Vite loads the appropriate file based on the current mode.
-   **Typing:** Must be declared in [src/frontend/src/app/types/vite-env.d.ts](mdc:src/frontend/src/app/types/vite-env.d.ts) within the `BuildTimeEnvironment` interface.
-   **Usage:** Accessed via `import.meta.env` within `environment.ts`.
-   **Use Case:** For variables that differ between build types, like `VITE_SENTRY_DSN`.

### 2. Injected Build-Time Variables

These are identifiers replaced with actual values by a Vite plugin during the build.

-   **Source:** Generated by the `@37bytes/vite-build-time-environment` plugin.
-   **Typing:** Provided automatically by the plugin's client types.
-   **Usage:** Consumed as global identifiers (e.g., `PACKAGE_INFO_FIELD_VERSION`) within `environment.ts`.
-   **Use Case:** To display build-specific information in the UI, such as version number, branch, and commit hash.

### 3. Dynamic Runtime Variables

These variables are loaded at runtime, allowing the same build artifact to be used across different environments.

-   **Source:** A `dynamicEnvironment.js` file, which is **not** part of the build artifact but is placed alongside `index.html` on the server.
-   **How it works:** The `@37bytes/vite-dynamic-environments` plugin injects a script into `index.html` to load `dynamicEnvironment.js`, which populates `window.dynamicEnvironment`.
-   **Typing:** Provided automatically by the plugin's client types.
-   **Usage:** Accessed via `window.dynamicEnvironment` within `environment.ts`.
-   **Use Case:** For variables that change between deployment environments (stands), like `STAND_NAME`. This is the most flexible approach.

---

## How to Add a New Environment Variable

1.  **Choose the Type:** Decide if the variable should be a build-time or dynamic runtime variable. Prefer **Dynamic Runtime** for flexibility if possible.
2.  **Add the Variable:**
    -   For **Build-Time:** Add `VITE_YOUR_VARIABLE_NAME` to the relevant `.env.*` files in `src/frontend/environments/`.
    -   For **Dynamic Runtime:** Add `YOUR_VARIABLE_NAME` to the template for `dynamicEnvironment.js`.
3.  **Declare the Type (for Build-Time only):**
    -   Open `src/frontend/src/app/types/vite-env.d.ts`.
    -   Add your new variable to the `BuildTimeEnvironment` interface.
    ```typescript
    interface BuildTimeEnvironment {
        readonly VITE_API_HOST: string;
        readonly VITE_SENTRY_DSN?: string;
        readonly VITE_YOUR_VARIABLE_NAME: string; // Your new variable
    }
    ```
4.  **Expose from `environment.ts`:**
    -   Open `src/frontend/src/shared/environment/environment.ts`.
    -   Import the variable from its source (`import.meta.env` or `window.dynamicEnvironment`).
    -   Export it as a constant for the rest of the application to use.
    ```typescript
    // Example for Build-Time
    export const YOUR_VARIABLE_NAME = import.meta.env.VITE_YOUR_VARIABLE_NAME;
    
    // Example for Dynamic Runtime
    export const YOUR_VARIABLE_NAME = window.dynamicEnvironment?.YOUR_VARIABLE_NAME ?? 'defaultValue';
    ```

---

## Architectural Notes on Robustness

At first glance, loading configuration at runtime via a `<script>` tag might seem risky. However, this system is designed to be highly robust, mitigating risks at the infrastructure level.

1.  **Centralized Build Process:** The [src/frontend/docker/Dockerfile](mdc:src/frontend/docker/Dockerfile) shows that all potential dynamic environment files are prepared in a `build-env` directory during the CI/CD process. This indicates an automated and centralized approach to managing configurations, not manual intervention.

2.  **Entrypoint Validation:** The key to this system's reliability is the `docker/entrypoint.sh` script. Before the web server (Nginx) is even started, this script:
    -   Checks for the existence of the correct `dynamicEnvironment.js` file for the specific stand (`$STAND`).
    -   If the file is missing, the script exits with an error code, causing the container launch to fail.

This design cleverly transforms a potential runtime client-side error (like a 404) into a loud, immediate, and easily detectable infrastructure failure during deployment. The application simply will not start with an invalid configuration.
